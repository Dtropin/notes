Class A{

void b() const; // этот const говорит о том, что метод может быть вызван на const объекте. Также это значит что из этого мтеода нельзя вызвать другие not const методы. 
//И самое главное - в этом методе нельзя изменять поля класса (не константные и за исключением статики, константные также изменить не выйдет, в этом и их смысл)

}

По большому счету, A a; И const A a; можно рассмтаривать как 2 разных типа со своими метадами (const и не const). Если объект const то для него будет вызвана const версия метода (если такая есть, если нет то ошибка компиляции). Для обычного - своя версия метода без const
Т.е. их можно перегружать таким образом

На константном объекте нельзя вызывать не константные методы!!! (Но можно наоборот на обычном вызывать константные)

В const методах нельзя менять значение не константных полей(кроме статики). 


Есть 2 типа "константности" - 

1) физическая, когда компилятор проверяет, что у константного поля (именно поля) ничего не меняется

НО это не касается разименовывания указателя (т.е. в const методе можно разименовать указатель не константный и туда записать любое значение), либо вообще вернуть reference и потом его зименить уже вне функции. Но сам указатель поменять не получится естественно

2) Это ведет к логической константности


2 метода которые отличаются только const приставкой, могут быть перегружены:

class A {
	void b() const;
	void b();
}


const A a;
A a2;

a.b(); - вызовется const метод
a2.b() - вызовется обычный метод


Есть ключевое слово mutable, которое позволяет менять в константных методах не константные поля (например у меняе сть константный объект но мне нужно в нем что то кешировать) а из-за ограничения я не смогу установить длину кеша в рантайме,
тут на помощь приходит mutable.

class A {

mutable int b;//Теперь может бьыть изменен в const методе

}

-----

const_cast<char&> - вроде убирает const 

char& a() {
		const char& b = 'a';
		return const_cast<char&>(b);
	}




