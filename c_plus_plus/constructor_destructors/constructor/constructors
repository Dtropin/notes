Если конструктор не указан, то компилятор сам создаст дефолтный конструктор, конструктор копирования и деструктор
Если есть хоть один конструктор с параметрами, то тогда дефолтный не сгенерится(Но это не касается конструткора копирования и присваивания, они сгенерятся если таковых соответственно нет и наличие обычнгог конструктора на них не влияет)

Собственно в дефолтных версиях конструктора копирования - он попытается скопировать поля из одного объектиа в другой(и причем сделает это правильно)

Оператор присваивания попытается себя также повести, но там есть свои задротские нюансы в результате которых код может не скомпилироваться




Также перед вызовом конструктора можно вызывать родительский конструктор с параметрами (или же дефолтный, но он поидее сам вызовется)

PriorityCustomer::PriorityCustomer(const PriorityCustomer& rhs) 
: Customer(rhs), // invoke base class copy ctor
priority(rhs.priority)
{
logCall("PriorityCustomer copy constructor");
}



Слово delete говорит компилятору не генерировать тот или иной конструктор (можно применять для копирования и присваивания), 
например если мы на конструктор копирования повесим delete то и вернуть объект по значению не сможем, т.к там вызывается конструктор копирования:


A A(const A&) = delete

A f() {
	return A(); - не скомпилируется
}


Слово const в конструкторе копирования нужно для того, чтобы можно было передавать туда const параметр при копировании (Можно и без него но тогда кейс работать не будет когда константу подаешь)
Если надо вообще избавится от всенх конструкторов копирования и тд, то надо проставлять delete и для const версий конструктора копирования (но это не касается оператора присваивания там может быть лишь один delete)
