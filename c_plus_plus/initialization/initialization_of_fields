reading unitialized values lead to undefined behaviour

Правила обписывающие когда объект будет проинициализирован а когда нет довольносложные
int x; - автоинициализируется нулем

class A {
int x,y; // Тут x может не всегда быть проинциализирован
}

Лучше всего на всякий случай всегда явно инициализировать переменные

По поводу конструктора в классах:

class A {

public:
	A(int c, list a) {
		this.c = c;
		this.a = a;

		//Значения здесь присваиваются, но при этом они не проиинциализированы! Инициализация же происходит раньше до того как поток входит в тело конструктора, т.е. получается, что 
		в данном примере c и a уже проинициализированы! И потом им еще раз присваивается значение c и a. 
	}
private:
	list a;
	int c;

}


Более правильный подход:

class A {

public:
        A(int c, list a):c(c),a(a) {     -- Здесь уже поля инициалищзируются а не присваиваются (при этом это делается до входа в конструктор). Т.е. тут присваивание == инициализация в отличие от предыдущего примера

        }
private:
        list a;
        int c;

}


Если тип данных не buil-in, то можно вызвать дефолтьный конструктор: Consttructor:c() {} -- вызывает дефолтьный конструктор у c (Хотя в этом нет особо смысла т.к. он и так будет вызван до входа в конструктор, просто это по большому счету "конвенция" которой стоит придерживаться в своем коде

Есть типы данных которые не приемлют assignment - ссылки и константы, поэтому тут нет другого выхода кроме как инциализировать так, как сказано выше (initialization member list)


Таким образом, "Тру" инициализация идет через member list, а "False" инциализация (точнее верно сказать не инциализация, а assignment) происходит уже в конструкторе


